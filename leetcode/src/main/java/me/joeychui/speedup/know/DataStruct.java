package me.joeychui.speedup.know;

public class DataStruct {
    // know 线性表：
    // know 数组
            // 数组排序接口 Arrays.sort(nums);

//    Arrays.sort(intervals, new Comparator<int[]>() {
//        public int compare(int[] interval1, int[] interval2) {
//            return interval1[0] - interval2[0];
//        }
//    });

    // know Set，Set<E> set = new HashSet<>(); new TreeSet();
    //          add() remove() get() contains() size()
    // know List，new ArrayList(); new LikedList();
    //           add() remove() get() contains() size()

    // know 栈，Deque<E> stack = new LikedList<>(); Deque<E> stack = new ArrayDeque<>(); 不要使用遗留类Stack
    //          push() pop() peak()

    // know 队列，Queue<E> queue = new LikedList<>(); 也可以用两个栈实现队列
    //           offer() poll() peak()

    // know 双端队列，Deque<E> deque = new LikedList<>(); Deque<E> deque = new ArrayDeque<>();
    //              offerFirst() offerLast() pollFirst() pollLast() peakFirst() peakLast()

    // know K-V结构，Map<E, E> map = new HashMap<>();
    //              put() remove() get() containsKey() size()

    // 8 - 5 = 3 ：[5, 8) 区间内3个整数，两个数字的距离是3
    // 整型溢出的问题 一些常数 Integer.MIN_VALUE(-2^31?) Integer.MAX_VALUE

    // 二叉树的遍历：前中后序 广度深度 递归迭代
    // 二叉树 完全二叉树 二叉搜索树（二叉排序树）


//    二叉搜索树BST是一棵空树，或者是具有下列性质的二叉树：
//
//    若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
//    若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
//    它的左、右子树也分别为二叉搜索树。

      // know 对于二叉搜索树，右子节点小于根节点的根节点
//    由这样的性质我们可以发现，二叉搜索树的中序遍历是一个单调递增的有序序列。如果我们反序地中序遍历该二叉搜索树，即可得到一个单调递减的有序序列。

//    广度优先搜索BFS（Breadth-First Search）
//    深度优先搜索DFS（Depth-First Search）
//    遍历traversal


}
