数据库-mysql





mysql数据隔离级别

未提交读

已提交读(问题：不可重复读)

可重复读

串行化



一个Page大小为16KB，若每行数据1KB，高度为3的的B+-Tree能管理4千多万行数据。



数据定义语言-DDL-Definition-CREATE、ALTER、DROP、TRUNCATE

数据查询语言-DQL-Query-select

数据操纵语言-DML-Manipulation-insert、update、delete

数据控制语言-DCL-Control





## 索引

**最左前缀原则：**where字段都在联合索引中而且包含联合索引第一个字段。符合最左前缀原则查询就能走索引。

**覆盖索引：**索引字段+主键字段覆盖了select字段。覆盖索引查询就不需要回表。

一条sql最终走不走索引，不是事先笃定的，具体看mysql优化器怎么执行。

1. 如果where字段有一个不在联合索引中，那么不符合最左前缀原则；
2. 如果where字段都在联合索引中，而且不包含联合索引第一个字段，那么不符合最左前缀原则；
3. 如果一条sql不符合最左前缀原则，那么查询时候是全表扫描，因为走不了索引；
4. 不覆盖索引就可能走不了索引，要全表扫描：
    1. 如果一条sql符合最左前缀原则但不覆盖索引，那么查询时候有可能走索引，但是要回表（也可能要全表扫描，因为先索引再回表可能不如直接全表扫描IO次数少）；
    2. 如果一条sql没有where子句而且有order子句但是不覆盖索引（尽管order子句覆盖索引），那么查询时候也可能要全表扫描（因为要回表）；
5. 覆盖索引，就能走索引，不用全表扫描：
    1. 如果一条sql符合最左前缀原则而且覆盖索引，那么查询时候无需回表，直接走索引，而不是全表扫描；
    2. 如果一条sql没有where子句但是覆盖索引，那么查询时候也走索引，而不是全表扫描（因为索引行数据量比真实行数据量小，每个Page存储的行数就多，Page总数就少，走索引相比全表扫描IO次数就少）；
    3. 如果一条sql没有where子句而且有order子句但是覆盖索引（order子句也覆盖索引），那么查询时候也走索引，而不是全表扫描（原因同上一条，而且直接有序）
6. 对字段进行操作，当需要类型转换时候，例如varchar转成int，会导致索引失效；

**举例，**假如对一个表t中有abcd四个字段，共6行数据，设有bcd的联合索引：

定值查询：最左前缀法则，where b c d、where b d 都能用上索引，where c d用不上索引

范围查询：select * from t where b > 1 不用索引，select * from t where b > 5用索引，select a, b from t where b > 5用索引



数据一致性指的什么：https://zhuanlan.zhihu.com/p/129049724





## 锁

我总结的加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。
原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。
原则2：查找过程中访问到的对象才会加锁。
优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。
优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。
一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。

https://km.sankuai.com/page/461569596

