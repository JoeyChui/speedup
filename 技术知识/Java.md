Java



volatile

Java中volatile修饰变量的作用：保证变量的可见性和有序性。详细来说：一是解决内存可见性问题，二是防止指令重排序。

其为Java提供了一种==轻量级的同步机制==：保证被volatile修饰的共享变量对所有线程总是可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总是可以被其他线程立即得知。相比于synchronized关键字（synchronized通常称为重量级锁），volatile更轻量级，开销低，因为它不会引起线程上下文的切换和调度。

可见性：是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改的值。

**内存可见性问题，指的是多个线程同时操作一个变量，其中某个线程修改了变量的值之后，其他线程感知不到变量的修改，这就是内存可见性问题。** **而使用 volatile 就可以解决内存可见性问题**：`那就是被volatile修饰的变量P被修改后，JMM会把该线程本地内存中的这个变量P，立即强制刷新到主内存中去，导致其他线程中的volatile变量P缓存无效，也就是说其他线程使用volatile变量P在时，都是从主内存刷新的最新数据`。而**普通变量的值在线程间传递的时候一般是通过主内存以共享内存的方式实现的**。

- 有序性，顾名思义即程序执行的顺序按照代码的先后顺序执行。但现代的计算机中CPU中为了能够让指令的执行尽可能地同时运行起来，提示计算机性能，采用了**指令流水线**。一个 CPU 指令的执行过程可以分成 4 个阶段：`取指、译码、执行、写回`。这 4 个阶段分别由 4 个独立物理执行单元来完成。

  理想的情况是：指令之间无依赖，可以使流水线的并行度最大化 但是如果两条指令的前后存在依赖关系，比如数据依赖，控制依赖等，此时后一条语句就必需等到前一条指令完成后，才能开始。所以CPU为了提高流水线的运行效率，对无依赖的前后指令做适当的乱序和调度，即现代的计算机中CPU是**乱序执行**指令的

  另一方面，只要不会改变程序的运行结果，Java编译器是可以通过**指令重排**来优化性能。然而，重排可能会影响本地处理器缓存与主内存交互的方式，可能导致在多线程的情况下发生"细微"的BUG。

  **指令重排**一般可以分为如下三种类型：

  - 编译器优化重排序，编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
  - 指令级并行重排序，现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
  - 内存系统重排序，由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。这并不是显式的将指令进行重排序，只是因为缓存的原因，让指令的执行看起来像乱序。

  从 Java 源代码到最终执行的指令序列，一般会经历下面三种重排序：

  编译器优化重排序 - 指令级并行重排序 - 内存系统重排序 

volatile关键字无法保证原子性 **，更准确地说是**`volatile关键字`**只能保证单操作的原子性，** 比如`x=1` **，但是无法保证复合操作的原子性**，比如`x++`

所谓原子性：即一个或者多个操作作为一个整体，要么全部执行，要么都不执行，并且操作在执行过程中不会被线程调度机制打断；而且这种操作一旦开始，就一直运行到结束，中间不会有任何上下文切换（context switch）

#### volatile为什么可以解决双重校验锁中的指令重排问题，参考这两个文章：

https://blog.csdn.net/java_1996/article/details/87472644

https://zhuanlan.zhihu.com/p/137460543



面向对象语言四大特点：继承、多态

## 集合

ArrayList

HashList

HashSet

HashMap